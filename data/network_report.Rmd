---
title: "Conservation Area: `r params$mpas`"
output:
  html_document:
    self_contained: true
    toc: true
    toc_depth: 3
    toc_float: false
params:
  mpas: "Maritimes"
---

## At-a-glance

```{r, echo=FALSE,comment=NA, results="asis", message=FALSE, warning=FALSE, error=FALSE}
if(!require(librarian)) install.packages("librarian")
pkgs <- c("sf",
          "targets",
          "viridis",
          "j-harbin/dataSPA",
          "arcpullr",
          "ArgoCanada/argoFloats",
          "casaultb/azmpdata",
          "raster",
          "dfo-mar-odis/TBSpayRates",
          "readxl",
          "ggplot2",
          "shinyBS",
          "Maritimes/Mar.datawrangling",
          "DT",
          "magrittr",
          "RColorBrewer",
          "dplyr",
          "tidyr",
          "stringr",
          "officer",
          "RColorBrewer",
          "car",
          "purrr",
          "dfo-mar-mpas/MarConsNetAnalysis",
          "dfo-mar-mpas/MarConsNetData",
          "dfo-mar-mpas/MarConsNetApp",
          "rnaturalearth",
          "DBI",
          "duckdb",
          "rmarkdown",
          "shiny",
          "measurements",
          "mregions2",
          "patchwork",
          "units",
          "dankelley/oceglider",
          "RCurl",
          "oce",
          "gsw",
          "leaflet",
          "rgbif",
          "qs",
          "qs2",
          "odbc",
          "rvest",
          "tarchetypes")
shelf(pkgs)

tar_load(c(MPAs,
           pillar_ecol_df,
           Context,
           flowerPalette,
           objective_tabs,
           N_Objectives,
           MPA_report_card,
           collaborations,
           creature_feature,
           cost_of_mpas,
           om,
           regions,
           Ecological,
           all_project_geoms,
           deliverables,
           csas,
           climate_change,
           salary,
           objective_tabs),
         store = path_to_store())

pillar_ecol_df2 <- pillar_ecol_df[order(pillar_ecol_df$indicator),]


###
# Starting Key findings:
kf1 <- pillar_ecol_df2[which(pillar_ecol_df2$areaID == params$mpas),]

kf_score <- calc_group_score(df=kf1,grouping_var = "bin",
                               score_var = "score",
                               weight_var = "weight")
kf_area_grade <- as.character(calc_letter_grade(weighted.mean(x=kf_score$score, w=kf_score$weight, na.rm=TRUE)))



###




if (any(pillar_ecol_df2$status_statement == "No features are represented.",na.rm = TRUE)) {
    pillar_ecol_df2$status_statement[pillar_ecol_df2$status_statement == "No features are represented."] <- paste0(
          "No features are represented. ** Note: a score will still be assigned if multiple MPAs are 'tied' for the lowest rank. ",
          "For example, if no features are represented but an MPA has a score of 50, this indicates that 50% of MPAs share the 'least represented' status."
        )
}

image_folder <- file.path(suppressMessages(dirname(path_to_store())),"data","plot")
image_files <- list.files(image_folder, full.names = TRUE)

if (any(MPAs$NAME_E == "Non_Conservation_Area")) {
MPAs2 <- MPAs[-which(MPAs$NAME_E == "Non_Conservation_Area"),]
MPAs2 <- MPAs2[which(MPAs2$region == params$mpas),]
} else {
  MPAs2 <- MPAs[which(MPAs$region == params$mpas),]
}

last_year <- paste0((as.numeric(format(Sys.time(), "%Y"))-1),"-", format(Sys.time(), "%Y"))
string <- params$mpas
network_context <- data_context(type="network")
cat(network_context)
cat("<br>")

```


```{r, echo=FALSE, comment=NA, results="asis"}

cat("The entirety of this report follows this legend:\n\n")

cat("<div style='display: flex; gap: 10px;'>")
PALETTE <- append(flowerPalette,list("NA" = "#EDEDED"))
for (name in names(PALETTE)) {
  color <- PALETTE[name]
  cat(sprintf("<div style='width: 50px; height: 20px; background-color: %s; text-align: center; 
               color: black; border: 1px solid #000; line-height: 20px;'>%s</div>", 
               color, name))
}
cat("</div>")
cat("<br>")

```


```{r, echo=FALSE, results='asis'}

maps <- leaflet() %>%
    addTiles()

for (i in seq_along(MPAs2$NAME_E)) {
  
  fill_color <- ifelse(
    is.na(MPA_report_card$grade[which(MPA_report_card$NAME_E == MPAs2$NAME_E[i])]),
    "#EDEDED",
    flowerPalette[[MPA_report_card$grade[which(MPA_report_card$NAME_E == MPAs2$NAME_E[i])]]]
  )
  
  border_color <- if (fill_color == "#ABD9E9") "black" else fill_color

  maps <- maps %>% 
    addPolygons(data=MPAs2$geoms[i], fillOpacity = 0.05, weight=2, color=border_color)
}

maps

cat(paste0("Figure 1: Location of ", string, " color coded for overall ecological status score"))


```

## Creature Feature

```{r, echo = FALSE, comment=NA, results="asis", warning=FALSE}
cat(paste0("Table 1: Species detected in ", string, " according to iNaturalist"))
cat("<br>")


try({
  
  
  datatable(
    creature_feature |> 
      group_by(speciesKey,scientificName,kingdom,phylum,class,commonname) |>
      filter(NAME_E %in% MPAs2$NAME_E) |> 
      reframe(n = sum(n),
              NAME_E = paste(unique(NAME_E), collapse = "; "),
              exampleurl = exampleurl[1],
              imageurl = imageurl[1],
              image_column = image_column[1]) |> 
      arrange(desc(n)) |>
      dplyr::select(commonname, image_column, scientificName, n, kingdom, phylum, class),

    # Disable sorting for the image column
    options = list(
      # Show 5 entries by default
      pageLength = 5,

      # Enable column-specific filtering
      initComplete = JS(
        "function(settings, json) {
          this.api().columns([1, 3, 4, 5, 6, 7]).every(function() {
            var column = this;
            var select = $('<select><option value=\"\"></option></select>')
              .appendTo($(column.footer()).empty())
              .on('change', function() {
                var val = $.fn.dataTable.util.escapeRegex(
                  $(this).val()
                );

                column
                  .search(val ? '^' + val + '$' : '', true, false)
                  .draw();
              });

            column.data().unique().sort().each(function(d, j) {
              select.append('<option value=\"' + d + '\">' + d + '</option>')
            });
          });
        }"
      )
    ),

    # Specify column names
    colnames = c(
      "Common Name",
      "Example Image",
      "Scientific Name",
      "iNaturalist Observations",
      "Kingdom",
      "Phylum",
      "Class"
    ),

    # Escape HTML to allow image rendering
    escape = FALSE,

    # Add some styling
    class = 'cell-border stripe hover',

    # Add footer for filtering
    filter = "bottom"
  )
})
```

```{r, echo=FALSE, comment=NA, results="asis", warning=FALSE}
p <- pillar_ecol_df2[which(pillar_ecol_df2$areaID == params$mpas),]

KEEP <- calc_group_score(df=p,grouping_var = "bin",
                               score_var = "score",
                               weight_var = "weight")
area_grade <- as.character(calc_letter_grade(weighted.mean(x=KEEP$score, w=KEEP$weight, na.rm=TRUE)))

```

## Results

<details>
<summary style="
    font-size: 1.8em;       /* make the text bigger */
    font-weight: bold;       /* make it bold */
    padding: 8px 12px;       /* space inside the box */
    border: 2px solid black; /* draw a box around the header */
    border-radius: 5px;      /* rounded corners */
    cursor: pointer;         /* show pointer on hover */
">
MANAGEMENT EFFECTIVENESS
</summary>




```{r, echo=FALSE, comment=NA, results="asis"}
cat("<br>")
cat('Management effectiveness analyses if conservation objectives are being met\n\n')

cat('<h3>Network Conservation Objectives</h3>\n')
cat('Click each objective to see information on relevant indicators.\n')


n_objectives <- trimws(substr(gsub("\n", "", N_Objectives), 2, nchar(gsub("\n", "", N_Objectives))), 'both')
filtered_odf <- objective_tabs[which(objective_tabs$objectives %in% n_objectives),]

grades_network <- NULL
grade_colors_network <- NULL
number_of_indicators <- NULL

for (i in seq_along(filtered_odf$objectives)) {
  # GRADES
  if (params$mpas %in% MPAs2$NAME_E) {
    KEEP <- pillar_ecol_df2[which(grepl(filtered_odf$objectives[i], pillar_ecol_df2$objectives, fixed=TRUE) & pillar_ecol_df2$areaID == params$mpas),]
  } else {
     KEEP <- pillar_ecol_df2[which(pillar_ecol_df2$areaID %in% MPAs2$NAME_E),]
  }
  KEEP$score[which(!(grepl(n_objectives[i], KEEP$objectives, fixed=TRUE)))] <- NA
  number_of_indicators[i] <- length(KEEP$indicator[KEEP$indicator != "placeholder" & !is.na(KEEP$score)])


  KEEP_df <- calc_group_score(df=KEEP,grouping_var = "bin",
                               score_var = "score",
                               weight_var = "weight")
  grades_network[i] <- as.character(calc_letter_grade(weighted.mean(x=KEEP_df$score, w=KEEP_df$weight, na.rm=TRUE)))

  if (!(all(is.na(KEEP$score)))) {
    grade_colors_network[i] <- unname(flowerPalette[which(names(flowerPalette) == grades_network[i])])
  } else {
    grade_colors_network[i] <- "#EDEDED"
  }
}



dt_data_network <- data.frame(
  Objective = filtered_odf$objectives,
  Grade = grades_network,
  stringsAsFactors = FALSE
)
```



```{r, echo=FALSE, comment=NA, results='asis', warning=FALSE}

# Container to hold all details blocks
all_details <- list()

for (i in seq_along(n_objectives)) {
  
  k1 <- which(grepl(n_objectives[i], pillar_ecol_df2$objectives, fixed=TRUE))
  if (params$mpas %in% regions$NAME_E) {
    k2 <- which(pillar_ecol_df2$region == state$mpas)
  } else {
    k2 <- which(pillar_ecol_df2$areaID == params$mpas)
  }
  keep <- intersect(k1,k2)
  if (!(length(keep) == 0)) {
    # FLOWER
    objective_flower <- pillar_ecol_df2[k2,]
    objective_flower$score[which(!(grepl(n_objectives[i], objective_flower$objectives, fixed=TRUE)))] <- NA

    p <- MarConsNetAnalysis::plot_flowerplot(objective_flower,
                                            grouping = "objective",
                                            labels = "bin",
                                            score = "score",
                                            max_score=100,
                                            min_score=0,
                                            title=" ")
    #print(p)
    img_file <- tempfile(fileext = ".png")
    ggplot2::ggsave(filename = img_file, plot = p, width = 6, height = 6, dpi = 120)


    unique_indicators <- unique(pillar_ecol_df2$indicator[keep])
    KK <- pillar_ecol_df2[keep,]
  
  # ADD CONDITION HERE

  # For each indicator, collect content & maps
  indicator_blocks <- list()
  
  for (j in seq_along(unique_indicators)) {
    indicator_name <- unique_indicators[j]
    KK2 <- KK[KK$indicator == indicator_name, ]
    KK2 <- KK2[KK2$areaID != "Non_Conservation_Area", ]
    
    # Text rationale
    rationale <- unique(KK2$indicator_rationale)
    
    # TEMPORARY FIX:
    if (indicator_name ==  "Nutrient Conditions (Phosphate)") {
      rationale <- "Changes in nutrient levels can affect biological productivity of the ocean and lead to trophic cascades (e.g., Petersen et al. 2017; Thingstad 2020)."
    }
    
    if (rationale == "FIXME") {
      rationale <- "There is no rationale yet available for this indicator."
    }
    
    # Create leaflet map for this indicator
    map <- leaflet() %>% addTiles()
    
    for (k in seq_along(KK2$areaID)) {
      area <- KK2$areaID[k]
      score <- pillar_ecol_df2$score[pillar_ecol_df2$areaID == area & pillar_ecol_df2$indicator == indicator_name]
      
      fill_color <- ifelse(
        length(score) == 0 || is.na(score),
        "#EDEDED",
        flowerPalette[[calc_letter_grade(score)]]
      )
      border_color <- if (fill_color == "#ABD9E9") "black" else fill_color
      
      map <- map %>%
        addPolygons(data = MPAs2[MPAs2$NAME_E == area, ], fillOpacity = 0.05, weight = 2, color = border_color)
    }
    
    # Compose indicator block with bold label, rationale text, and map widget
    indicator_blocks[[j]] <- tagList(
      tags$b(paste("Indicator:", indicator_name)),
      tags$p(rationale),
      map,
      tags$hr()
    )
  } 
 
  details_block <- tags$details(
    tags$summary(
    style = "
      cursor: pointer;
      font-weight: bold;
      font-size: 1.2em;
      padding: 4px 8px;
      border-radius: 4px;
      margin-bottom: 5px;",
    tags$u(
      n_objectives[i],
      tags$span(
        style = sprintf(
          "background-color:%s; padding:2px 6px; border-radius:4px;",
          grade_colors_network[i]
        ),
        ifelse(!(grades_network[i] == "NA"), grades_network[i], " ")
      )
    )
  ),
     tags$img(
    src = img_file,
    style = "max-width: 350px; display:block; margin: 10px 0;"
  ),
    tagList(indicator_blocks)
  )
  all_details[[length(all_details) + 1]] <- details_block
  
  } else {
     # If no indicators in this bin, add a simple message block
    details_block <- tags$details(
        tags$summary(
    style = "
      cursor: pointer;
      font-weight: bold;
      font-size: 1.2em;
      padding: 4px 8px;
      border-radius: 4px;
      margin-bottom: 5px;",
    tags$u(
      n_objectives[i],
      tags$span(
        style = sprintf(
          "background-color:%s; padding:2px 6px; border-radius:4px;",
          grade_colors_network[i]
        ),
        ifelse(!(grades_network[i] == "NA"), grade_colors_network[i], " ")
      )
    )
  ),
      "There are no indicators for this objective."
    )
    all_details[[length(all_details) + 1]] <- details_block
    next
    
  }
}

# Render all the details blocks combined as the chunk output
tagList(all_details)


```


</details> <details>
<summary style="
    font-size: 1.8em;       /* make the text bigger */
    font-weight: bold;       /* make it bold */
    padding: 8px 12px;       /* space inside the box */
    border: 2px solid black; /* draw a box around the header */
    border-radius: 5px;      /* rounded corners */
    cursor: pointer;         /* show pointer on hover */
">
ECOLOGICAL OVERVIEW
</summary>

```{r, echo=FALSE, comment=NA, results="asis", warning=FALSE}
cat("<br>")
cat('Ecological overview analyses the health of the overall ecosystem\n\n')

cat('<h2>Flower Plot</h2>\n')

flower_df <- pillar_ecol_df2[which(pillar_ecol_df2$areaID == "Maritimes"),]
flower_df <- flower_df[which(is.na(flower_df$scale)),]


plot_flowerplot(flower_df,
                                            grouping = "objective",
                                            labels = "bin",
                                            score = "score",
                                            max_score=100,
                                            min_score=0,
                                            title="Flower plot frame work")
```





```{r, echo=FALSE, results='asis'}
# dfdt <- data.frame(Pressure=c("Fishing", "Research", "Vessel", "Cables", "Offshore", "Contaminant Debris", "Cumulative Impacts"), Metrics=NA, Score=NA)
# print(knitr::kable(dfdt, caption = "Threats Table",row.names=FALSE))

if (params$mpas %in% regions$NAME_E) {
  table_ped <- pillar_ecol_df2[which(!(pillar_ecol_df2$areaID %in% regions$NAME_E)),]
  
} else {
  table_ped <- pillar_ecol_df2[which(pillar_ecol_df2$areaID == params$mpas),]
}
if (any(table_ped$indicator == "placeholder") | any(is.na(table_ped$indicator))) {
  table_ped <- table_ped[-which(table_ped$indicator == 'placeholder' | is.na(table_ped$indicator)),]
}

table_ped <- table_ped[,c("bin", "indicator", "source", "score", "weight", "PPTID", 'readiness')]


ddff <- table_ped %>%
  left_join(
    Ecological %>% dplyr::select(labels, grouping),
    by = c("bin" = "labels")   # bin in table_ped matches labels in Ecological
  ) %>%
  # Add placeholders for readiness, quality, cost
  mutate(
    quality   = NA_real_,
    cost      = NA_real_
  ) %>%
  dplyr::select(grouping, bin, indicator, source, score, readiness, quality, cost, PPTID) %>%
  arrange(grouping, bin) %>%
  setNames(toupper(names(.)))

if (params$mpas %in% regions$NAME_E) {
  # FIXME!!!!!
  
  ddff_unique <- ddff %>%
    rowwise() %>%
    mutate(
      SCORE = weighted.mean(
        x = table_ped$score[table_ped$indicator == INDICATOR & table_ped$bin == BIN],
        w = table_ped$weight[table_ped$indicator == INDICATOR & table_ped$bin == BIN],
        na.rm = TRUE
      )
    ) %>%
    ungroup() %>%
    distinct(GROUPING, BIN, INDICATOR, SOURCE, SCORE, READINESS, QUALITY, COST, PPTID)
  
} else {
  ddff_unique <- ddff
}
costing <- NULL
if (!(length(ddff_unique$PPTID) == 0)) {
  for (i in seq_along(unique(ddff_unique$PPTID))) {
    ppt <- unique(ddff_unique$PPTID)[i]
    if (is.na(ppt)) {
      costing[i] <- "External"
      ddff_unique$COST[which(is.na(ddff_unique$PPTID))] <- "External"
    } else {
      costing[i] <- paste0("$", round(unique(cost_of_mpas$price_per_station[which(cost_of_mpas$project_id == ppt)]),2), "/ sample")
      ddff_unique$COST[which(ddff_unique$PPTID == unique(ddff_unique$PPTID)[i])] <- paste0("$", round(unique(cost_of_mpas$price_per_station[which(cost_of_mpas$project_id == ppt)]),2), "/ sample")
      
    }
  }
  #ddff_unique$READINESS <- "Ready"
  
     ddff_display <- ddff_unique %>%
        arrange(GROUPING, SOURCE) %>%                # make sure sources are together within grouping
        group_by(GROUPING, SOURCE) %>%
        mutate(COST = ifelse(row_number() == 1, COST, "")) %>%  # only first row of each SOURCE shows COST
        ungroup()

  # example: add table headers
  cat('<h4 style="text-align:left; margin-bottom:10px;">Table 3: Ecological Overview Summary</h4>\n')
cat('<table border="1" style="border-collapse:collapse; width:100%;">\n')
  cat('<thead><tr>',
      paste0('<th>', c("GROUPING", "BIN", "INDICATOR", "SOURCE", "SCORE", "READINESS", "QUALITY", "COST", "GRADE"), '</th>', collapse=""),
      '</tr></thead>\n')
  cat('<tbody>\n')
  
  colgrade <- NA
  for (i in seq_len(nrow(ddff_display))) {
    # if you want row coloring, define here
    colgrade <- calc_letter_grade(ddff_display$SCORE[i])   # your function
    if (!(is.na(colgrade))) {
      if (!(colgrade == "NA")) {
        row_color <- flowerPalette[[colgrade]]
      } else {
        row_color <- "#EDEDED"
      }
    } else {
      row_color <- "#EDEDED"
    }
    
    # lookup the color for that grade
    
    
  cat('<tr>')
 cat('<td style="background-color:white;">', ddff_display$GROUPING[i], '</td>')
  cat('<td style="background-color:white;">', ddff_display$BIN[i], '</td>')
  cat('<td style="background-color:white;">', ddff_display$INDICATOR[i], '</td>')
  cat('<td style="background-color:white;">', ddff_display$SOURCE[i], '</td>')
  cat('<td style="background-color:white;">', sprintf("%.2f", ddff_display$SCORE[i]), '</td>')
  cat('<td style="background-color:white;">', ddff_display$READINESS[i], '</td>')
  cat('<td style="background-color:white;">', ddff_display$QUALITY[i], '</td>')
  cat('<td style="background-color:white;">', ddff_display$COST[i], '</td>')
  
  # ✅ Grade column — last, colored cell, blank inside (or replace "" with grade letter)
  cat(sprintf('<td style="background-color:%s; font-weight:bold; text-align:center;">%s</td>',
              row_color,
              ""))  # leave blank, or use grade to display the letter

  cat('</tr>\n')
  }
  
  cat('</tbody></table>')
}

```


As shown above, in `r params$mpas` the over all grade based on our criteria is `r area_grade` with each bin having the following grade:


```{r, echo=FALSE, comment=NA, results="asis"}
# Create an empty data frame to store results
summary_table <- data.frame(
  `Indicator Bin` = character(),
  `Grade` = character(),
  `Number of Indicators` = character(),
  stringsAsFactors = FALSE
)

# Loop through bins and calculate grades
for (i in seq_along(unique(p$bin))) {
  keep <- which(p$bin == unique(p$bin)[i])
  df <- p[keep, ]
  group_df <- calc_group_score(df=df,grouping_var = "bin",
                               score_var = "score",
                               weight_var = "weight")
  grade <- as.character(calc_letter_grade(weighted.mean(x=group_df$score, w=group_df$weight, na.rm=TRUE)))
  
  if (any(is.na(df$indicator) | df$indicator == "placeholder" | is.na(df$score))) {
  indicatorLength <- length(unique(df$indicator[-which(is.na(df$indicator) | df$indicator == "placeholder" | is.na(df$score))]))
  } else {
    indicatorLength <- length(unique(df$indicator))
  }
  
  summary_table[i, ] <- c(unique(p$bin)[i], grade, indicatorLength)
}

# Print as a table
print(knitr::kable(summary_table, caption = "Grades by Indicator Bin"))


```


```{r, echo=FALSE, comment=NA, results='asis'}


# Container to hold all details blocks
all_details <- list()

BINS <- unique(trimws(tolower(unlist(strsplit(pillar_ecol_df2$bin, ";"))), "both"))

keeper <- pillar_ecol_df2[-which(pillar_ecol_df2$areaID %in% regions$NAME_E),]

FILL_COLORS <- NULL
BIN_SCORE <- NULL

for (i in seq_along(BINS)) {
  
  bin_upper <- toupper(BINS[i])
  
  KK <- keeper[grepl(BINS[i], trimws(tolower(keeper$bin), "both")), ]
  
  # Remove NA, placeholder, or missing score
  KK <- KK[!(is.na(KK$indicator) | KK$indicator == "placeholder" | is.na(KK$score)), ]
  
  if (nrow(KK) == 0) {
    # If no indicators in this bin, add a simple message block
    details_block <- tags$details(
        tags$summary(
    style = "
      cursor: pointer;
      font-weight: bold;
      font-size: 1.2em;
      padding: 4px 8px;
      border-radius: 4px;
      margin-bottom: 5px;",
    tags$u(
      bin_upper,
      tags$span(
        style = sprintf(
          "background-color:%s; padding:2px 6px; border-radius:4px;",
          FILL_COLORS[i]
        ),
        ifelse(!(BIN_SCORE[i] == "NA"), BIN_SCORE[i], " ")
      )
    )
  ),
      "There are no indicators for this bin."
    )
    all_details[[length(all_details) + 1]] <- details_block
    next
  }
  
  unique_indicators <- unique(KK$indicator)
  
  # For each indicator, collect content & maps
  indicator_blocks <- list()
  
  for (j in seq_along(unique_indicators)) {
    indicator_name <- unique_indicators[j]
    KK2 <- KK[KK$indicator == indicator_name, ]
    KK2 <- KK2[KK2$areaID != "Non_Conservation_Area", ]
    
    # Text rationale
    rationale <- unique(KK2$indicator_rationale)
    
    # Create leaflet map for this indicator
    map <- leaflet() %>% addTiles()
    
    for (k in seq_along(KK2$areaID)) {
      area <- KK2$areaID[k]
      score <- pillar_ecol_df2$score[pillar_ecol_df2$areaID == area & pillar_ecol_df2$indicator == indicator_name & tolower(pillar_ecol_df2$bin) == BINS[i]]
      
      fill_color <- ifelse(
        length(score) == 0 || is.na(score),
        "#EDEDED",
        flowerPalette[[calc_letter_grade(score)]]
      )
      border_color <- if (fill_color == "#ABD9E9") "black" else fill_color
      
      FILL_COLORS[i] <- fill_color
      BIN_SCORE[i] <- calc_letter_grade(score)
      
      map <- map %>%
        addPolygons(data = MPAs2[MPAs2$NAME_E == area, ], fillOpacity = 0.05, weight = 2, color = border_color)
    }
    
    # Compose indicator block with bold label, rationale text, and map widget
    indicator_blocks[[j]] <- tagList(
      tags$b(paste("Indicator:", indicator_name)),
      tags$p(rationale),
      map,
      tags$hr()
    )
  }
  
  # Compose the whole details block for this bin
  
  details_block <- tags$details(
    tags$summary(
    style = "
      cursor: pointer;
      font-weight: bold;
      font-size: 1.2em;
      padding: 4px 8px;
      border-radius: 4px;
      margin-bottom: 5px;",
    tags$u(
      bin_upper,
      tags$span(
        style = sprintf(
          "background-color:%s; padding:2px 6px; border-radius:4px;",
          FILL_COLORS[i]
        ),
        ifelse(!(BIN_SCORE[i] == "NA"), BIN_SCORE[i], " ")
      )
    )
  ),
    #tags$summary(tags$strong(paste(bin_upper))),
    tagList(indicator_blocks)
  )
  
  all_details[[length(all_details) + 1]] <- details_block
}

# Render all the details blocks combined as the chunk output
tagList(all_details)


```

</details> <details>
<summary style="
    font-size: 1.8em;       /* make the text bigger */
    font-weight: bold;       /* make it bold */
    padding: 8px 12px;       /* space inside the box */
    border: 2px solid black; /* draw a box around the header */
    border-radius: 5px;      /* rounded corners */
    cursor: pointer;         /* show pointer on hover */
">
THREATS
</summary>
```{r, echo=FALSE, results='asis'}
cat("<br>")
cat(paste0("Table: Threat indicators in ", string, "\n"))


if (!(length(ddff_unique$PPTID) == 0)) {
  
  ddff_unique <- ddff_unique[which(grepl("Threats", ddff_unique$BIN)),]
  
  ddff_threats <- ddff_unique %>%
        arrange(GROUPING, SOURCE) %>%                # make sure sources are together within grouping
        group_by(GROUPING, SOURCE) %>%
        mutate(COST = ifelse(row_number() == 1, COST, "")) %>%  # only first row of each SOURCE shows COST
        ungroup()

  # example: add table headers
  cat('<table border="1" style="border-collapse:collapse; width:100%;">\n')
  cat('<thead><tr>',
      paste0('<th>', c("GROUPING", "BIN", "INDICATOR", "SOURCE", "SCORE", "READINESS", "QUALITY", "COST", "GRADE"), '</th>', collapse=""),
      '</tr></thead>\n')
  cat('<tbody>\n')
  
  for (i in seq_len(nrow(ddff_threats))) {
    # if you want row coloring, define here
    grade <- calc_letter_grade(ddff_threats$SCORE[i])   # your function
    if (!(is.na(grade))) {
      if (!(grade == "NA")) {
        row_color <- flowerPalette[[grade]]
      } else {
        row_color <= "#EDEDED"
      }
    } else {
      row_color <= "#EDEDED"
    }
    
    # lookup the color for that grade
    
     cat('<tr>')
 cat('<td style="background-color:white;">', ddff_threats$GROUPING[i], '</td>')
  cat('<td style="background-color:white;">', ddff_threats$BIN[i], '</td>')
  cat('<td style="background-color:white;">', ddff_threats$INDICATOR[i], '</td>')
  cat('<td style="background-color:white;">', ddff_threats$SOURCE[i], '</td>')
  cat('<td style="background-color:white;">', sprintf("%.2f", ddff_threats$SCORE[i]), '</td>')
  cat('<td style="background-color:white;">', ddff_threats$READINESS[i], '</td>')
  cat('<td style="background-color:white;">', ddff_threats$QUALITY[i], '</td>')
  cat('<td style="background-color:white;">', ddff_threats$COST[i], '</td>')
  
  # ✅ Grade column — last, colored cell, blank inside (or replace "" with grade letter)
  cat(sprintf('<td style="background-color:%s; font-weight:bold; text-align:center;">%s</td>',
              row_color,
              ""))  # leave blank, or use grade to display the letter

  cat('</tr>\n')
  }
  
  cat('</tbody></table>')
}

```
</details>

## Investment Information

```{r, echo=FALSE, comment=FALSE, results='asis', message=FALSE, warning=FALSE}

cost_of_mpas2 <- cost_of_mpas[which(cost_of_mpas$area %in% MPAs2$NAME_E),]

if (length(cost_of_mpas2$project_id) != 0) {

  projects <- unique(cost_of_mpas2$project_id)

  # Dealing with O&M First
  OMs <- list()
  for (i in seq_along(projects)) {
    percent_sites_in_network <- sum(cost_of_mpas2$percent_sites_in_mpa[which(cost_of_mpas2$project_id == projects[i])])
    om$amount[which(as.numeric(om$project_id) == as.numeric(projects[i]))] <- om$amount[which(as.numeric(om$project_id) == as.numeric(projects[i]))]*percent_sites_in_network
    OMs[[i]] <- om[which(as.numeric(om$project_id) == as.numeric(projects[i])),]
  }
  network_om <- do.call(rbind, OMs)
  plotly_plot <- try(dataSPA::plotSPA(om=network_om, which="omBar"), silent=TRUE)

  # Print statement for O&M

  # Now Dealing with Salary
  SALs <- list()
   for (i in seq_along(projects)) {
    percent_sites_in_network <- sum(cost_of_mpas2$percent_sites_in_mpa[which(cost_of_mpas2$project_id == projects[i])])
    salary$amount_week[which(as.numeric(salary$project_id) == as.numeric(projects[i]))] <- salary$amount_week[which(as.numeric(salary$project_id) == as.numeric(projects[i]))]*percent_sites_in_network
    SALs[[i]] <- salary[which(as.numeric(salary$project_id) == as.numeric(projects[i])),]
  }
  network_salary <- do.call(rbind, SALs)
  salary_plot <-  try(dataSPA::plotSPA(salary=network_salary, which="salaryBar"), silent=TRUE)

  tagList(
    tags$p("Disclaimer: The cost information is based on the funding information in the Project Planning Tool. The amount is based on percentage of samples taken in the area of interest compared to the total samples."),
    tags$p("At the network level, each project is analyzed to determine the percentage of samples taken in each protected area in the network. This percentage is added up and the O&M investment is then multiplied by that percentage."),
    tags$p("For example. If 30% of data from a project was taken in St. Anns Bank, and 20% in the Gully, the amount invested in the Maritimes region for that project would be 30+20% = 50%. The amount invested would then be multiplied by 50% for each funding source. "),
    plotly_plot,
    tags$p("The same logic can be applied to the salary information below. Note that overtime is not considered in this calculation."),
    salary_plot,
    tags$p("Below highlights the total (O&M, Salary, and Capital) investement broken up by protected area. This is calculated by individually looking at each area, then looking at each project sampled in that area. For each project in a given area, the percent of samples taken in the area is determined. This amount for each project is multiplied by this percentage to determine a dollar value. The sum of these dollar values in each protected area is added and the pie chart is created.")
  )

} else {
  tags$p("There is no internal investment information available for this area.")
}


```

```{r, echo=FALSE, comment=FALSE, results='asis', message=FALSE, warning=FALSE}

pie_area <- unique(cost_of_mpas2$area)
ps <- split(cost_of_mpas2, cost_of_mpas2$area)

adjusted_ps <- list()
for (i in seq_along(ps)) {
  PS <- ps[[i]]
  adjusted_ps[[i]] <- data.frame(
    project_id = PS$project_id,
    amount = rep(NA, length(PS$project_id))
  )
  for (j in seq_along(PS$project_id)) {
    keep <- which(om$project_id == PS$project_id[j])
    adjusted_ps[[i]]$amount[j] <- sum(om$amount[keep] * PS$percent_sites_in_mpa[j])
  }
}


# Adding in the salary information for total cost per protected area
adjusted_ps_salary <- list()
for (i in seq_along(ps)) {
  PS <- ps[[i]]
  adjusted_ps_salary[[i]] <- data.frame(
    project_id = PS$project_id,
    amount = rep(NA, length(PS$project_id))
  )
  for (j in seq_along(PS$project_id)) {
    keep <- which(salary$project_id == PS$project_id[j])
    adjusted_ps_salary[[i]]$amount[j] <- sum(salary$amount_week[keep] * PS$percent_sites_in_mpa[j])
  }
}

final_funding <- lapply(adjusted_ps, function(x) sum(x$amount))
final_funding_salary <- lapply(adjusted_ps_salary, function(x) sum(x$amount))

names(final_funding) <- names(ps)
names(final_funding_salary) <- names(ps)


TOTAL_FUNDING <- NULL
for (i in seq_along(final_funding)) {
  TOTAL_FUNDING[i] <- round(final_funding[[i]]+final_funding_salary[[i]],2)
}

bad <- which(unname(TOTAL_FUNDING) == 0)

df <- data.frame(
  MPA = names(final_funding)[-bad],
  Funding = unname(unlist(final_funding))[-bad]
) %>%
  mutate(Funding_pct = Funding / sum(Funding))

# CREATING LEAFLET MAP OF SAMPLES
## Starting with polygon info
mpa_colors <- brewer.pal(n = length(df$MPA), name = "Set3")

apg <- all_project_geoms[-which(is.na(all_project_geoms$PPTID)),]
if (any(apg$areaID == "Non_Conservation_Area")) {
  apg <- apg[-which(apg$areaID == "Non_Conservation_Area"),]
}
# Create a new geometry list with rounded coords
rounded_geoms <- st_sfc(
  lapply(st_geometry(apg), function(pt) {
    coords <- st_coordinates(pt)
    coords_rounded <- round(coords, 2)
    coords_vec <- as.numeric(coords_rounded[1, ])
    st_point(coords_vec)
  }),
  crs = st_crs(apg)
)

# Then assign back to the sf object properly
st_geometry(apg) <- rounded_geoms

# Now find unique geometries
apg_unique <- apg %>% distinct(geometry, .keep_all = TRUE)

# Getting lat and lng
coords_df <- do.call(rbind, lapply(st_geometry(apg_unique), function(pt) {
  c(lng = pt[1], lat = pt[2])
}))

# Add as columns to apg
apg_unique <- apg_unique %>%
  mutate(
    lng = coords_df[, "lng"],
    lat = coords_df[, "lat"]
  )

# Getting colors for polygons
names(mpa_colors) <- df$MPA
fill_colors <- mpa_colors[df$MPA]

# Replace any NA colors with grey if needed
fill_colors[is.na(fill_colors)] <- "grey"
fill_colors <- as.character(fill_colors)

money_mpas <- MPAs2[which(MPAs2$NAME_E %in% df$MPA),]

# GETTING PROJECTS
pptids <- unique(apg_unique$PPTID)

marker_color <- "lightblue"

# Assign FA icons for shapes
#shape_icons <- c("circle", "square", "star", "triangle", "heart") #FIXME: May need more.
shape_icons <- c("anchor", "ship", "circle", "life-ring", "sailboat", "map-marker", "globe", "compass", "flag", "cloud", "water", "tint", "wave-square", "sun-o", "moon-o", "star", "bolt", "paper-plane", "location-arrow", "road", "truck", "ship-wheel", "life-ring", "circle", "square", "circle-o", "square-o", "dot-circle-o")


# Legend work
shape_map <- setNames(rep(shape_icons, length.out = length(pptids)), pptids)

# Set icons
apg_unique$map_icons <- NA
for (i in seq_along(pptids)) {
  apg_unique$map_icons[which(apg_unique$PPTID == as.numeric(pptids[i]))] <- shape_map[[which(names(shape_map) == pptids[i])]]
}

icons <- awesomeIcons(
  icon = apg_unique$map_icons,
  iconColor = "black",
  library = "fa",
  markerColor = marker_color
)


# Build legend items dynamically:
legend_items <- paste0(
  "<i class='fa fa-", shape_map[pptids], "' style='color: ", marker_color, ";'></i> ", pptids
)

# Combine into one HTML string
legend_html <- paste0(
  "<div style='background: white; padding: 8px; font-family: Arial;'>",
  "<b>Legend</b><br>",
  paste(legend_items, collapse = "<br>"),
  "</div>"
)


map <- leaflet(apg_unique) %>%
  addTiles() %>%
  addPolygons(
    data = money_mpas$geoms,
    fillColor = fill_colors,
    fillOpacity = 0.9,
    color = "grey30",
    weight = 3,
    opacity = 1
  ) %>%
  addAwesomeMarkers(
    ~lng, ~lat,
    icon = icons,
    popup = ~paste("Project ID:", PPTID)
  ) %>%
  addControl(
    html = legend_html,
    position = "bottomright"
  )

# ggplot pie chart
gg_pie <- ggplot(df, aes(x = "", y = Funding_pct, fill = MPA)) +
  geom_col(width = 1) +
  coord_polar(theta = "y") +
  scale_fill_manual(values = mpa_colors) +
  labs(title = "Percentage of Funding by MPA", fill = "Protected Area") +
  theme_void()

#gg_pie
temp_file <- tempfile(fileext = ".png")
ggsave(temp_file, plot = gg_pie, width = 6, height = 4, dpi = 150)

tagList(
  tags$div(style = "display: flex; gap: 20px; align-items: center;",
           tags$div(style = "flex: 1;",
                    tags$img(src = base64enc::dataURI(file = temp_file, mime = "image/png"), style = "max-width: 100%; height: auto;")
           )
           #,
           #tags$div(style = "flex: 1;", map)
  )
)

```



## Discussion

```{r, echo=FALSE, warning=FALSE, error=FALSE, results="asis", message=FALSE}


cat("### Status\n")

cat(paste0("In ", string, " there is an overall ecological status score of ", kf_area_grade, ". This is based on a total of ", length(unique(ddff_display$INDICATOR)), " indicators. Of these ", length(unique(ddff_display$INDICATOR)), " indicators, ", length(which(ddff_display$SCORE>49)), " indicators are receiving a 'pass' score of 50 or greater."))

if (kf_area_grade %in% c("A", "B", "C")) {
  cat(paste0("The results suggest that the MPA is maintaining a healthy environmental condition."))
} else if (area_grade == "NA") {
  cat(paste0("Insufficient data are available to assess ecological condition, highlighting the need for monitoring to better understand and manage the MPA’s environmental health"))
} else {
  cat(paste0("This indicates that ecological conditions are below expectations, highlighting the need for targeted management actions to improce ecosystem health."))
}

if (length(unique(ddff_display$INDICATOR)) < 5) {
  cat(paste0("Though, it should be noted that additional work should be considered to add more indicators in this area."))
}

# Code for print statement
obj_ex <- read_excel(file.path(dirname(path_to_store()), "data", "objectives.xlsx"))


# JAIM FIX 
now_what <- NULL
for (i in seq_along(n_objectives)) {
  msg <- paste0(n_objectives[i], 
    " had a score of ", grades_network[i], 
    ", that is based on ", number_of_indicators[i], " indicators. "
  )
  
  # Conditional addition
  if (length(grades_network)<1){
    msg <- paste0(msg, " It is reccomended that further work be considered to support this objective.")
  } else if(grades_network[i] == "NA") {
    msg <- paste0(msg, " It is reccomended that further work be considered to support this objective.")
  } else if (grades_network[i] %in% c("A", "B", "C")) {
    msg <- paste0(msg, obj_ex$Success[which(obj_ex$Objective == n_objectives[i])])
  } else {
    msg <- paste0(msg, obj_ex$Continue_Work[which(obj_ex$Objective == n_objectives[i])])
    
  }
  
  if ( !is.null(number_of_indicators[i])){
    if (number_of_indicators[i] < 5) {
      msg <- paste0(msg, "Additional work should also be considered to add more indicators to support this objective.")
    }
  }
  msg <- paste0(msg, '\n\n')
  
  now_what[i] <- msg
}

cat("\n\n")
cat(paste0("From a management perspective,"))
cat("\n\n")
cat(now_what)
cat("\n\n")



cat("### Climate Change\n")

climate_indicators <- unique(pillar_ecol_df2$indicator[which(grepl("Inside", pillar_ecol_df2$indicator) & pillar_ecol_df2$areaID == params$mpa)])

for (i in seq_along(climate_indicators)) {
  indicator_keep <- which(pillar_ecol_df2$indicator == gsub(" Inside Outside Comparison$", "", climate_indicators[i]) & pillar_ecol_df2$areaID == params$mpas)
  
  if (!(length(indicator_keep) == 0) & !(is.na(pillar_ecol_df2$trend_statement[indicator_keep]))) {
    
    excel_keep <- which(climate$Indicator == climate_indicators[i])
    pillar_keep_inside <- which(pillar_ecol_df2$indicator == climate_indicators[i] & pillar_ecol_df2$areaID == params$mpas)
    
    cat(sprintf("<b>Indicator: %s.</b>\n\n",toupper(climate_indicators[i])))
    
    cat(climate$Context[excel_keep], "\n\n")
    cat("In our analysis, ")
    cat(pillar_ecol_df2$trend_statement[indicator_keep])
    
    if (!(grepl("There is only one year of data", pillar_ecol_df2$trend_statement[indicator_keep]))) {
    
    pval <- str_extract(pillar_ecol_df2$trend_statement[indicator_keep], "pval\\s*=\\s*\\d+(\\.\\d+)?") |>
      str_extract("\\d+(\\.\\d+)?") |>
      as.numeric()
    
    if (pval > 0.05) {
      cat(". The change in this indicator in the MPA is not significant.")
    } else {
      cat(". The change in this indicator in the MPA is significant.")
    }
    
    cat(" An inside/outside comparison was done to help understand the impacts of climate change on this variable. Results showed ")
    
    result <- pillar_ecol_df2$status_statement[pillar_keep_inside]
    
    cat(paste0(tolower(result), "."))
    
    if (!(grepl("Protection could therefore be positively impacting this variable", result))) {
      # No sig dif between the two
      desired <- sub(".*\\s+", "", pillar_ecol_df2$scoring[indicator_keep])
      actual_results <- ifelse(grepl("increase", sub("\\..*", ".", pillar_ecol_df2$trend_statement[indicator_keep])), "increase", "decrease")
      
      if (pval > 0.05) { ## This is pval of the variable (not inside/ outside)
        cat("The rate in which this indicator is changing is not significant (p=", pval,") which suggests that climate change does not seem to have a significant impact on that particular indicator.")
      } else {
        # change is significant
        if (identical(desired, actual_results)) {
          cat("The results show us that climate change doesn't seem to be impacting this indicator the way we would expect, and in fact, the trends are showing a statistically significant trend in the opposite direction than we would expect.")
        } else {
          #The trend is going in the opposite direction that we would expect and
          #statistically significant,we point out that according to our analysis
          cat("The results show us that climate change could be impacting this indicator the way we would expect, and in fact, the trends are showing a statistically significant
        trend in the direction than we would expect as a result of climate change.")
        }
      }
    }
    } else {
    cat("More sampling is suggested.")
  }
  }
  
  cat("\n\n")
}

cat("### Research Recommendations \n")

cat(paste0(
  "The following indicator bins do not have any data: ",
  paste0(summary_table$Indicator.Bin[which(summary_table$Grade == "NA")], collapse = ", "),
  ". It is recommended to further study these areas.\n"
))
cat("\n\n")

# Bad grade table
badGrade <- which(pillar_ecol_df2$areaID == params$mpas & (!(is.na(pillar_ecol_df2$indicator))) & (!(pillar_ecol_df2$indicator == "placeholder")) & (!(grepl('Inside Outside', pillar_ecol_df2$indicator))) & (pillar_ecol_df2$score < 51 | is.na(pillar_ecol_df2$score)))

badGradeTable <- pillar_ecol_df2[badGrade, ] |> 
  dplyr::group_by(bin) |>
  dplyr::ungroup() |>
  dplyr::select("indicator", "score")

```



## Outreach and engagement

### Collaborations and partnerships


```{r, echo=FALSE, warning=FALSE, error=FALSE, results="asis"}
project_subset <- pillar_ecol_df2$PPTID[which(pillar_ecol_df2$areaID == params$mpas)]
if (!(length(project_subset) == 0)) {
p_subset <- unique(trimws(unlist(strsplit(project_subset, ";")), "both"))
}
if (any(is.na(p_subset))) {
  p_subset <- p_subset[-which(is.na(p_subset))]
}
if (any(p_subset == "NA")) {
  p_subset <- p_subset[-which(p_subset == "NA")]
}

# if (any(p_subset %in% collaborations$project_id)) {
#   good_col <- which(collaborations$project_id %in% p_subset)
#   collab_subset <- collaborations[good_col,]
# 
#   ## For collaborations, I need to obtain the year. This would allow me to say 'for this year, x collaborations happened, but in previous years for this project, Y collaborations have happened).
# 
#   #last_year <- paste0((as.numeric(format(Sys.time(), "%Y"))-1),"-", format(Sys.time(), "%Y"))
# 
#   year_keep <- which(collab_subset$fiscal_year == last_year)
# 
#   if (!(length(year_keep) == 0)) {
#     recent_col <- collab_subset[year_keep, !(names(collab_subset) %in% c("project_year_id", "new_or_existing", "type", "critical"))]
#     names(recent_col) <- c("Project ID", "Organization", "Year")
# 
#    organizations <- unique(recent_col$Organization)
#     rc <- data.frame(Organization=organizations)
# 
#     for (i in seq_along(organizations)) {
#       keeping <- which(recent_col$Organization == organizations[i])
#       rc$Year[i] <- paste0(sort(unique(recent_col[keeping,]$Year)), collapse= ", ")
#     }
#     cat(paste0("The following collaborations/partnerships were identified for ", last_year, " for projects that contributed to this site:"))
#     cat("\n\n")
# 
#     print(knitr::kable(rc, caption = "Recent Collaborations and Partnerships",row.names=FALSE))
#     cat("\n\n")
#   } else {
#   cat(paste0("In year ", last_year, " there were no identified collaborations/ partnerships. /n/n"))
#   }
#   if (!(length(which((!(1:length(collab_subset$project_id)%in% year_keep))))) == 0) {
# 
#     cat("The following past partnerships/collaborations have been identified and contributed to this site: \n\n")
#     past_coll <- collab_subset[-year_keep, !(names(collab_subset) %in% c("project_year_id", "new_or_existing", "type", "critical"))]
#     names(past_coll) <- c("Project ID", "Organization", "Year")
#     organizations <- unique(past_coll$Organization)
#     pc <- data.frame(Organization=organizations)
# 
#     for (i in seq_along(organizations)) {
#       keeping <- which(past_coll$Organization == organizations[i])
#       pc$Year[i] <- paste0(sort(unique(past_coll[keeping,]$Year)), collapse= ", ")
#     }
# 
#     print(knitr::kable(pc, caption = "Past Collaborations and Partnerships",row.names=FALSE))
# 
#   } else {
#     cat("There are no partnerships/collaborations identified from previous years. \n\n")
#   }
# } else {
#     cat("There have been no identified collaborations/ partnerships for this area using the Project Planning Tool. \n\n")
# }
```

### Deliverables

```{r, echo=FALSE, error=FALSE, warning=FALSE, results='asis'}
deliv_keep <- which(deliverables$project_id %in% p_subset & deliverables$year == last_year) # Only projects for this area / last year

if (length(deliv_keep > 0)) {
  delv <- deliverables[deliv_keep,][c("classification_display", "description")]
  if (any(str_count(delv$description, "\\S+") > 35)) {
  delv$description[which(str_count(delv$description, "\\S+") > 35)] <- " "
  }
  
  names(delv) <- c("Deliverable", "Description")
  
  print(knitr::kable(delv, caption = paste0("Deliverables for " , last_year ),row.names=FALSE))
} else {
  cat("There has been no identified deliverables in the Project Planning Tool for projects supporting this area.")
}

```

### CSAS

```{r, echo=FALSE, error=FALSE, warning=FALSE, results='asis'}
# Which ones to keep
csas_keep <- which(grepl(paste(params$mpas, collapse = "|"), csas$title)) # params$mpas
if (params$mpas == "Western and Emerald Banks Marine Refuge") {
csas_keep <- c(csas_keep, which(grepl("Emerald Banks", csas$title, ignore.case=TRUE)))
} else if (params$mpas ==  "St. Anns Bank Marine Protected Area") {
  csas_keep <- c(csas_keep, which(grepl("Anns", csas$title, ignore.case=TRUE)))
} else if (params$mpas == "Musquash Estuary Marine Protected Area") {
  csas_keep <- c(csas_keep, which(grepl("Musquash", csas$title, ignore.case=TRUE)))
}

if (length(csas_keep) > 0) {
  CSAS <- csas[csas_keep,]
  names(CSAS) <- c("Title", "Date")
  print(knitr::kable(CSAS, caption = paste0("CSAS Processes for " , params$mpas),row.names=FALSE))
} else {
  cat("There have been no identified relevant CSAS meetings in the CSAS DMapps related to this area.")
}




```


